http://blog.csdn.net/lovelion/article/details/17517213

(一) 创建型

-,  简单工厂模式(3)
产品接口 Product
工厂类 Factory
Producer Factory.getProduct(String productType)

1,  工厂方法模式(5)
产品接口 Product
工厂接口 Factory createProduct()
具体的工厂类，重写createProduct方法，返回具体的Product实例
HelloProduct new HelloFactory().createProduct()

2,  抽象工厂模式(5)
产品接口 Product
工厂接口 Factory createProduct1() && createProduct2() && createProduct3()
具体的工厂类，重写所有的createProduct&()方法，返回一组具体的Product实例

3， 单例模式(4)
饿汉式 
懒汉式 双重检查锁以及violent
静态内部类
只有一个值的枚举类

4， 原型模式(3)
clone方法
深复制和浅复制

5， 建造者模式(2)
Actor ActorController(or Director).construct(Builder builder)
导演构建，传入具体的构建器，经过一系列的步骤，构建出具体的演员对象

（二） 结构型

6， 适配器模式(4)
Adapter 实现Target(需要被包装的类)接口，然后继承Adaptee(新的，用来适配的接口)类中的方法，并在其中做转化

7， 桥接模式(3)
把一个接口传进另外一个接口，然后就可以实现矩阵型的逻辑关联

8， 组合模式(4)
对待集合和个体，继承统一的接口，然后统一处理

9， 装饰模式(3)
Decorator同样继承Component接口，然后把之前的具体Component作为参数传入，然后返回Component接口对象使用

10，外观模式(5)
为客户端提供一组任务的一个简单的调用，隐藏具体复杂的内部实现细节

11，享元模式(1)


12，代理模式(4)
Proxy同样继承Subject接口，然后在里面实例化Subject的具体实例，然后想干嘛就干嘛

（三） 行为型

13，责任链模式(2)
接口类作为实例类的一个属性，如果符合条件处理请求，否则由该接口的下一个实现处理请求
客户端的代码负责责任的分配

14，命令模式(4)
调用类持有命令类的接口作为属性，在其中执行方法调用。方法在接口的命令具体类中实现(handler类做具体的处理)
调用类可以使用不同的命令类传入，进行不同的命名操作。

15，解释器模式(1)

16，迭代器模式(5)
创建单一职责的迭代器类，处理具体的迭代细节实现

17，中介者模式(2)
新建一个类，用来管理和处理所有类错综复杂的关联和细节，减少类之间的依赖关系

18，备忘录模式(2)
具体类中持有备忘录类的属性，然后备忘录类以具体类为参数提供存储和恢复的方法

19，观察者模式(5)
主题对象中，持有所有观察者对象的引用，观察者可以选择加入或者退出
当一个事件被触发之后，所有订阅的观察者接受到通知。

20，状态模式(3)
在context类中有状态类的属性，通过设定不同的状态类来实现系统的统一管理和不同状态的切换
不同的状态下，都业务逻辑的处理是不相同的，需要子类来具体实现

21，策略模式(4)
一个具体的算法簇，已经规定了具体的实现流程，需要根据需要注入不同的实现细节

22，模板方法模式(3)
可复用的样板代码首先实现，然后剩下的不一样的功能代码由具体子类负责实现

23，访问者模式(1)


3个不常用： 享元模式 + 解释器模式 + 访问者模式